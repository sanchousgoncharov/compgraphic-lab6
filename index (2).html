<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Визуализатор многогранников</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cbc;
            --accent-color: #ff6b6b;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-radius: 8px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-color);
            background-color: #f5f7fa;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .canvas-container {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background-color: white;
        }

        .controls {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 20px;
            overflow-y: auto;
            max-height: 80vh;
        }

        .control-group {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 14px;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        .coordinate-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .projection-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .parallel-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .active-button {
            background-color: var(--accent-color);
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D Визуализатор многогранников</h1>
        </header>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h2>Выбор фигуры</h2>
                <div class="form-group">
                    <select id="figure-select">
                        <option value="1">Тетраэдр</option>
                        <option value="2" selected>Куб (Гексаэдр)</option>
                        <option value="3">Октаэдр</option>
                        <option value="4">Икосаэдр</option>
                        <option value="5">Додекаэдр</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <h2>Проекция</h2>
                <div class="projection-buttons">
                    <button id="perspectiveButton" class="active-button">Перспективная</button>
                    <button id="axonometricButton">Аксонометрическая</button>
                </div>
            </div>

            <div class="control-group">
                <h2>Вращение</h2>
                <div class="form-group">
                    <label>X: <span id="rotateXValue">0°</span></label>
                    <input type="range" id="rotateX" min="0" max="360" step="1" value="0">
                </div>
                <div class="form-group">
                    <label>Y: <span id="rotateYValue">0°</span></label>
                    <input type="range" id="rotateY" min="0" max="360" step="1" value="0">
                </div>
                <div class="form-group">
                    <label>Z: <span id="rotateZValue">0°</span></label>
                    <input type="range" id="rotateZ" min="0" max="360" step="1" value="0">
                </div>
            </div>

            <div class="control-group">
                <h2>Масштаб и смещение</h2>
                <div class="form-group">
                    <label>Масштаб: <span id="scaleValue">1.0</span></label>
                    <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1">
                </div>
                <div class="form-group">
                    <label>Смещение X: <span id="translateXValue">0</span></label>
                    <input type="range" id="translateX" min="-3" max="3" step="0.1" value="0">
                </div>
                <div class="form-group">
                    <label>Смещение Y: <span id="translateYValue">0</span></label>
                    <input type="range" id="translateY" min="-3" max="3" step="0.1" value="0">
                </div>
                <div class="form-group">
                    <label>Смещение Z: <span id="translateZValue">0</span></label>
                    <input type="range" id="translateZ" min="-3" max="3" step="0.1" value="0">
                </div>
            </div>

            <div class="control-group">
                <h2>Отражение</h2>
                <div class="checkbox-group">
                    <input type="checkbox" id="reflectXY">
                    <label for="reflectXY">Относительно XY</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reflectXZ">
                    <label for="reflectXZ">Относительно XZ</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reflectYZ">
                    <label for="reflectYZ">Относительно YZ</label>
                </div>
            </div>

            <div class="control-group">
                <h2>Вращение вокруг прямой через центр</h2>
                <div class="parallel-buttons axis-buttons">
                    <button id="parallelX" class="active-button">X</button>
                    <button id="parallelY">Y</button>
                    <button id="parallelZ">Z</button>
                </div>
                <div class="form-group">
                    <label>Смещение Y: <span id="parallelOffsetYValue">0</span></label>
                    <input type="range" id="parallelOffsetY" min="-2" max="2" step="0.1" value="0">
                </div>
                <div class="form-group">
                    <label>Смещение Z: <span id="parallelOffsetZValue">0</span></label>
                    <input type="range" id="parallelOffsetZ" min="-2" max="2" step="0.1" value="0">
                </div>
                <div class="form-group">
                    <label>Угол: <span id="parallelRotationValue">0°</span></label>
                    <input type="range" id="parallelRotation" min="0" max="360" step="1" value="0">
                </div>
            </div>

            <div class="control-group">
                <h2>Вращение вокруг произвольной прямой</h2>
                <div class="form-group">
                    <label>Точка A:</label>
                    <div class="coordinate-inputs">
                        <input type="number" id="AxInput" value="0" step="0.1">
                        <input type="number" id="AyInput" value="0" step="0.1">
                        <input type="number" id="AzInput" value="0" step="0.1">
                    </div>
                </div>
                <div class="form-group">
                    <label>Точка B:</label>
                    <div class="coordinate-inputs">
                        <input type="number" id="BxInput" value="1" step="0.1">
                        <input type="number" id="ByInput" value="0" step="0.1">
                        <input type="number" id="BzInput" value="0" step="0.1">
                    </div>
                </div>
                <div class="form-group">
                    <label>Угол: <span id="angleValue">0°</span></label>
                    <input type="range" id="angleRotationLine" min="0" max="360" step="1" value="0">
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Класс точки в 3D пространстве
        class Point3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            toArray() {
                return [this.x, this.y, this.z];
            }
            
            // Создание копии точки
            clone() {
                return new Point3D(this.x, this.y, this.z);
            }
        }

        // Класс грани (многоугольника)
        class Face {
            constructor(vertexIndices) {
                this.vertexIndices = vertexIndices;
            }
        }

        // Класс многогранника
        class Polyhedron {
            constructor(vertices, faces) {
                this.vertices = vertices.map(v => new Point3D(...v));
                this.faces = faces.map(f => new Face(f));
                this.center = this.calculateCenter();
            }
            
            // Вычисление центра многогранника
            calculateCenter() {
                const sum = this.vertices.reduce((acc, vertex) => {
                    return new Point3D(
                        acc.x + vertex.x,
                        acc.y + vertex.y, 
                        acc.z + vertex.z
                    );
                }, new Point3D(0, 0, 0));
                
                const count = this.vertices.length;
                return new Point3D(sum.x / count, sum.y / count, sum.z / count);
            }
            
            // Создание копии многогранника
            clone() {
                const vertices = this.vertices.map(v => v.toArray());
                const faces = this.faces.map(f => [...f.vertexIndices]);
                return new Polyhedron(vertices, faces);
            }
        }

        // Класс для работы с матрицами преобразований
        class TransformationMatrix {
            static getIdentityMatrix() {
                return [
                    [1, 0, 0, 0],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
            }
            
            static multiplyMatrices(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < b[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < a[0].length; k++) {
                            sum += a[i][k] * b[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }
            
            static multiplyMatrixVector(m, v) {
                return [
                    m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2] + m[0][3],
                    m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2] + m[1][3],
                    m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2] + m[2][3],
                    m[3][0]*v[0] + m[3][1]*v[1] + m[3][2]*v[2] + m[3][3]
                ];
            }
            
            static getRotationXMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    [1, 0, 0, 0],
                    [0, c, -s, 0],
                    [0, s, c, 0],
                    [0, 0, 0, 1]
                ];
            }
            
            static getRotationYMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    [c, 0, s, 0],
                    [0, 1, 0, 0],
                    [-s, 0, c, 0],
                    [0, 0, 0, 1]
                ];
            }
            
            static getRotationZMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return [
                    [c, -s, 0, 0],
                    [s, c, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
            }
            
            static getScaleMatrix(scale) {
                return [
                    [scale, 0, 0, 0],
                    [0, scale, 0, 0],
                    [0, 0, scale, 0],
                    [0, 0, 0, 1]
                ];
            }
            
            static getTranslationMatrix(dx, dy, dz) {
                return [
                    [1, 0, 0, dx],
                    [0, 1, 0, dy],
                    [0, 0, 1, dz],
                    [0, 0, 0, 1]
                ];
            }
            
            static getReflectionMatrix(reflectXY, reflectXZ, reflectYZ) {
                let matrix = this.getIdentityMatrix();
                // Отражение относительно XY (меняем знак Z)
                if (reflectXY) matrix[2][2] = -1;
                // Отражение относительно XZ (меняем знак Y)
                if (reflectXZ) matrix[1][1] = -1;
                // Отражение относительно YZ (меняем знак X)
                if (reflectYZ) matrix[0][0] = -1;
                return matrix;
            }
            
            // Масштабирование относительно центра
            static getScaleAroundCenterMatrix(scale, center) {
                const toOrigin = this.getTranslationMatrix(-center.x, -center.y, -center.z);
                const scaling = this.getScaleMatrix(scale);
                const backFromOrigin = this.getTranslationMatrix(center.x, center.y, center.z);
                
                let matrix = this.multiplyMatrices(toOrigin, scaling);
                return this.multiplyMatrices(matrix, backFromOrigin);
            }
            
            // Вращение вокруг произвольной прямой (матрица Родригеса)
            static getRotationAroundLineMatrix(pointA, pointB, angle) {
                const [ax, ay, az] = pointA.toArray();
                const [bx, by, bz] = pointB.toArray();
                
                // Вектор направления прямой
                const u = bx - ax;
                const v = by - ay;
                const w = bz - az;
                
                const length = Math.sqrt(u*u + v*v + w*w);
                if (length === 0) return this.getIdentityMatrix();
                
                const l = u / length;
                const m = v / length;
                const n = w / length;
                
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                const oneMinusCosA = 1 - cosA;
                
                // Матрица вращения Родригеса
                const rotationMatrix = [
                    [
                        l*l*oneMinusCosA + cosA,
                        m*l*oneMinusCosA - n*sinA,
                        n*l*oneMinusCosA + m*sinA,
                        0
                    ],
                    [
                        l*m*oneMinusCosA + n*sinA,
                        m*m*oneMinusCosA + cosA,
                        n*m*oneMinusCosA - l*sinA,
                        0
                    ],
                    [
                        l*n*oneMinusCosA - m*sinA,
                        m*n*oneMinusCosA + l*sinA,
                        n*n*oneMinusCosA + cosA,
                        0
                    ],
                    [0, 0, 0, 1]
                ];
                
                // Комбинируем с трансляцией к началу координат и обратно
                const toOrigin = this.getTranslationMatrix(-ax, -ay, -az);
                const fromOrigin = this.getTranslationMatrix(ax, ay, az);
                
                let matrix = this.multiplyMatrices(toOrigin, rotationMatrix);
                return this.multiplyMatrices(matrix, fromOrigin);
            }
            
            // Вращение вокруг прямой через центр, параллельной координатной оси
            static getRotationAroundParallelAxisMatrix(axis, angle, offsetY, offsetZ, center) {
                // Создаем точку на прямой, проходящей через центр и параллельной выбранной оси
                let pointOnLine;
                switch(axis) {
                    case 'x':
                        pointOnLine = new Point3D(center.x, center.y + offsetY, center.z + offsetZ);
                        break;
                    case 'y':
                        pointOnLine = new Point3D(center.x + offsetY, center.y, center.z + offsetZ);
                        break;
                    case 'z':
                        pointOnLine = new Point3D(center.x + offsetY, center.y + offsetZ, center.z);
                        break;
                }
                
                // Создаем вторую точку на прямой (смещенную по направлению оси)
                let directionPoint;
                switch(axis) {
                    case 'x':
                        directionPoint = new Point3D(pointOnLine.x + 1, pointOnLine.y, pointOnLine.z);
                        break;
                    case 'y':
                        directionPoint = new Point3D(pointOnLine.x, pointOnLine.y + 1, pointOnLine.z);
                        break;
                    case 'z':
                        directionPoint = new Point3D(pointOnLine.x, pointOnLine.y, pointOnLine.z + 1);
                        break;
                }
                
                // Используем метод для вращения вокруг произвольной прямой
                return this.getRotationAroundLineMatrix(pointOnLine, directionPoint, angle);
            }
        }

        // Класс визуализатора многогранников
        class PolyhedronViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.initFigures();
                this.setupEventListeners();
                this.currentProjection = 'perspective';
                
                this.transformParams = {
                    rotateX: 0, rotateY: 0, rotateZ: 0,
                    scale: 1,
                    translateX: 0, translateY: 0, translateZ: 0,
                    reflectXY: false, reflectXZ: false, reflectYZ: false,
                    lineA: new Point3D(0, 0, 0),
                    lineB: new Point3D(1, 0, 0),
                    rotationAngle: 0,
                    parallelAxis: 'x',
                    parallelOffsetY: 0,
                    parallelOffsetZ: 0,
                    parallelRotationAngle: 0
                };
                
                this.currentFigure = this.figures[2];
                this.draw();
            }
            
            initFigures() {
                this.figures = {
                    1: this.createTetrahedron(),
                    2: this.createCube(),
                    3: this.createOctahedron(),
                    4: this.createIcosahedron(),
                    5: this.createDodecahedron()
                };
            }
            
            createTetrahedron() {
                const vertices = [
                    [0, 0, Math.sqrt(8/3)], 
                    [Math.sqrt(8/3), 0, -Math.sqrt(8/9)],
                    [-Math.sqrt(2/3), Math.sqrt(2), -Math.sqrt(8/9)],
                    [-Math.sqrt(2/3), -Math.sqrt(2), -Math.sqrt(8/9)]
                ];
                const faces = [
                    [0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]
                ];
                return new Polyhedron(vertices, faces);
            }
            
            createCube() {
                const vertices = [
                    [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                    [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
                ];
                const faces = [
                    [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4],
                    [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5]
                ];
                return new Polyhedron(vertices, faces);
            }
            
            createOctahedron() {
                const vertices = [
                    [0, 0, 1], [1, 0, 0], [0, 1, 0], 
                    [-1, 0, 0], [0, -1, 0], [0, 0, -1]
                ];
                const faces = [
                    [0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1],
                    [5, 1, 2], [5, 2, 3], [5, 3, 4], [5, 4, 1]
                ];
                return new Polyhedron(vertices, faces);
            }
            
            createIcosahedron() {
                const t = (1 + Math.sqrt(5)) / 2;
                const vertices = [
                    [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                    [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                    [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
                ];
                const faces = [
                    [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                    [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                    [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                    [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
                ];
                return new Polyhedron(vertices, faces);
            }
            
			createDodecahedron() {
				const phi = (1 + Math.sqrt(5)) / 2;
				const invPhi = 1 / phi;

				// Вершины 
				const vertices = [
					[ 1,  1,  1], [ 1,  1, -1], [ 1, -1,  1], [ 1, -1, -1],
					[-1,  1,  1], [-1,  1, -1], [-1, -1,  1], [-1, -1, -1],
					[ 0,  invPhi,  phi], [ 0, -invPhi,  phi], [ 0,  invPhi, -phi], [ 0, -invPhi, -phi],
					[ invPhi,  phi, 0], [-invPhi,  phi, 0], [ invPhi, -phi, 0], [-invPhi, -phi, 0],
					[ phi, 0,  invPhi], [-phi, 0,  invPhi], [ phi, 0, -invPhi], [-phi, 0, -invPhi]
				];

				// Нормализация
				const lens = vertices.map(v => Math.hypot(v[0], v[1], v[2]));
				const avg = lens.reduce((a,b)=>a+b,0) / lens.length || 1;
				const scale = 1 / avg;
				const scaled = vertices.map(v => [v[0]*scale, v[1]*scale, v[2]*scale]);

				// Построение ребер: у каждой вершины 3 ближайших соседа 
				const n = scaled.length;
				const dist2 = (a,b) => {
					const dx = a[0]-b[0], dy = a[1]-b[1], dz = a[2]-b[2];
					return dx*dx + dy*dy + dz*dz;
				};

				// найдем три ближайших для каждой вершины
				const neighbors = Array.from({length: n}, () => new Set());
				for (let i = 0; i < n; i++) {
					// массив [dist, j]
					const arr = [];
					for (let j = 0; j < n; j++) {
						if (i === j) continue;
						arr.push([dist2(scaled[i], scaled[j]), j]);
					}
					arr.sort((a,b) => a[0] - b[0]);
					// берем 3 ближайших
					for (let k = 0; k < 3; k++) {
						neighbors[i].add(arr[k][1]);
					}
				}
				// сделаем симметричный граф (если i сосед j, то j сосед i)
				for (let i = 0; i < n; i++) {
					neighbors[i].forEach(j => neighbors[j].add(i));
				}

				// Поиск всех простых циклов длины 5
				// Ограничение: у нас небольшой граф, можно перебрать DFS от каждой вершины
				const isNeighbor = (a,b) => neighbors[a].has(b);
				const cyclesSet = new Set();
				const cycles = [];

				const minOfArray = arr => arr.reduce((a,b)=> Math.min(a,b), Infinity);

				// Канонизировать цикл (повороты и реверсы) -> минимальная строка
				function canonicalCycle(arr) {
					const m = arr.length;
					let best = null;
					for (let shift = 0; shift < m; shift++) {
						// прямой порядок
						const cand1 = arr.slice(shift).concat(arr.slice(0, shift));
						const str1 = cand1.join(',');
						if (best === null || str1 < best) best = str1;
						// обратный порядок
						const cand2 = cand1.slice().reverse();
						const str2 = cand2.join(',');
						if (str2 < best) best = str2;
					}
					return best;
				}

				// Проверка планарности: все точки лежат в одной плоскости (с допуском eps)
				function isPlanar(indices) {
					const p0 = scaled[indices[0]];
					const p1 = scaled[indices[1]];
					const p2 = scaled[indices[2]];
					// нормаль = (p1-p0) x (p2-p0)
					const v1 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]];
					const v2 = [p2[0]-p0[0], p2[1]-p0[1], p2[2]-p0[2]];
					const nrm = [
						v1[1]*v2[2] - v1[2]*v2[1],
						v1[2]*v2[0] - v1[0]*v2[2],
						v1[0]*v2[1] - v1[1]*v2[0]
					];
					const nl = Math.hypot(nrm[0], nrm[1], nrm[2]);
					if (nl < 1e-8) return false; // вырожденный треугольник
					const nx = nrm[0]/nl, ny = nrm[1]/nl, nz = nrm[2]/nl;
					// расстояние каждой точки до плоскости (dot(n, p - p0))
					const eps = 1e-6;
					for (let k = 3; k < indices.length; k++) {
						const pk = scaled[indices[k]];
						const d = nx*(pk[0]-p0[0]) + ny*(pk[1]-p0[1]) + nz*(pk[2]-p0[2]);
						if (Math.abs(d) > eps) return false;
					}
					return true;
				}

				// DFS-поиск циклов длины 5
				for (let start = 0; start < n; start++) {
					const stack = [[start]];
					while (stack.length) {
						const path = stack.pop();
						if (path.length === 5) {
							// проверим замкнутость: есть ли ребро между last и start
							const last = path[path.length-1];
							if (isNeighbor(last, start)) {
								// чтобы избежать дубликатов, потребуем, чтобы start был минимальным индекс в цикле
								if (start !== minOfArray(path)) continue;
								// canonical и добавление
								const can = canonicalCycle(path);
								if (!cyclesSet.has(can)) {
									const indices = can.split(',').map(x=>parseInt(x,10));
									// дополнительно проверим планарность (пятиугольник должен быть плоским)
									if (isPlanar(indices)) {
										cyclesSet.add(can);
										cycles.push(indices);
									}
								}
							}
							continue;
						}
						const last = path[path.length-1];
						neighbors[last].forEach(nb => {
							// не возвращаемся назад и не повторяем вершины в пути
							if (path.includes(nb)) return;
							// ограничение: чтобы избежать длинных веток, можно потребовать nb > start OR allow — но уже фильтруем по minOfArray при приёме
							// продлеваем путь
							const newPath = path.concat([nb]);
							stack.push(newPath);
						});
					}
				}

				// Ожидаем найти ровно 12 циклов (граней)
				// Но на всякий случай оставим только уникальные и длины 5
				const faces = cycles.filter(c => c.length === 5);

				// Если по какой-то причине алгоритм не дал 12 граней (защита) — падаем на заранее заданный список (безопасный запас)
				if (faces.length !== 12) {
					// запасной (один из корректных наборов для этой нумерации вершин)
					// этот список берётся как fallback и гарантирует корректность связности
					return new Polyhedron(scaled, [
						[0, 8, 9, 2, 16],
						[0, 16, 17, 4, 12],
						[0, 12, 13, 1, 8],
						[1, 13, 14, 3, 10],
						[1, 10, 11, 5, 9],
						[2, 9, 5, 15, 18],
						[2, 18, 19, 6, 16],
						[3, 14, 13, 12, 17],
						[3, 17, 16, 6, 19],
						[4, 8, 1, 10, 11],
						[4, 11, 7, 15, 12],
						[5, 11, 10, 3, 14]
					]);
				}

				return new Polyhedron(scaled, faces);
			}



            setupEventListeners() {
                document.getElementById('figure-select').addEventListener('change', (e) => {
                    this.currentFigure = this.figures[e.target.value];
                    this.draw();
                });
                
                document.getElementById('perspectiveButton').addEventListener('click', () => {
                    this.currentProjection = 'perspective';
                    this.updateActiveButton('perspectiveButton');
                    this.draw();
                });
                
                document.getElementById('axonometricButton').addEventListener('click', () => {
                    this.currentProjection = 'axonometric';
                    this.updateActiveButton('axonometricButton');
                    this.draw();
                });
                
                ['rotateX', 'rotateY', 'rotateZ'].forEach(axis => {
                    document.getElementById(axis).addEventListener('input', (e) => {
                        this.transformParams[axis] = parseFloat(e.target.value) * Math.PI / 180;
                        document.getElementById(`${axis}Value`).textContent = `${e.target.value}°`;
                        this.draw();
                    });
                });
                
                document.getElementById('scale').addEventListener('input', (e) => {
                    this.transformParams.scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = e.target.value;
                    this.draw();
                });
                
                ['translateX', 'translateY', 'translateZ'].forEach(axis => {
                    document.getElementById(axis).addEventListener('input', (e) => {
                        this.transformParams[axis] = parseFloat(e.target.value);
                        document.getElementById(`${axis}Value`).textContent = e.target.value;
                        this.draw();
                    });
                });
                
                ['reflectXY', 'reflectXZ', 'reflectYZ'].forEach(plane => {
                    document.getElementById(plane).addEventListener('change', (e) => {
                        this.transformParams[plane] = e.target.checked;
                        this.draw();
                    });
                });
                
                document.getElementById('angleRotationLine').addEventListener('input', (e) => {
                    this.transformParams.rotationAngle = parseFloat(e.target.value) * Math.PI / 180;
                    document.getElementById('angleValue').textContent = `${e.target.value}°`;
                    this.draw();
                });
                
                ['Ax', 'Ay', 'Az', 'Bx', 'By', 'Bz'].forEach(coord => {
                    document.getElementById(`${coord}Input`).addEventListener('input', (e) => {
                        const point = coord[0] === 'A' ? this.transformParams.lineA : this.transformParams.lineB;
                        const axis = coord[1].toLowerCase();
                        point[axis] = parseFloat(e.target.value);
                        this.draw();
                    });
                });
                
                // Обработчики для вращения вокруг параллельной оси
                ['parallelX', 'parallelY', 'parallelZ'].forEach(axis => {
                    document.getElementById(axis).addEventListener('click', () => {
                        this.transformParams.parallelAxis = axis.slice(-1).toLowerCase();
                        this.updateActiveParallelButton(axis);
                        this.draw();
                    });
                });
                
                document.getElementById('parallelOffsetY').addEventListener('input', (e) => {
                    this.transformParams.parallelOffsetY = parseFloat(e.target.value);
                    document.getElementById('parallelOffsetYValue').textContent = e.target.value;
                    this.draw();
                });
                
                document.getElementById('parallelOffsetZ').addEventListener('input', (e) => {
                    this.transformParams.parallelOffsetZ = parseFloat(e.target.value);
                    document.getElementById('parallelOffsetZValue').textContent = e.target.value;
                    this.draw();
                });
                
                document.getElementById('parallelRotation').addEventListener('input', (e) => {
                    this.transformParams.parallelRotationAngle = parseFloat(e.target.value) * Math.PI / 180;
                    document.getElementById('parallelRotationValue').textContent = `${e.target.value}°`;
                    this.draw();
                });
                
                this.updateActiveParallelButton('parallelX');
            }
            
            updateActiveButton(activeId) {
                document.querySelectorAll('.projection-buttons button').forEach(btn => {
                    btn.classList.remove('active-button');
                });
                document.getElementById(activeId).classList.add('active-button');
            }
            
            updateActiveParallelButton(activeId) {
                document.querySelectorAll('.parallel-buttons button').forEach(btn => {
                    btn.classList.remove('active-button');
                });
                document.getElementById(activeId).classList.add('active-button');
            }
            
            projectPerspective(point) {
                const c = 5; // расстояние до плоскости проекции
                const scale = 100;
                
                const perspectiveMatrix = [
                    [scale, 0, 0, 0],
                    [0, -scale, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, -1/c, 1]
                ];
                
                let [x, y, z, w] = TransformationMatrix.multiplyMatrixVector(perspectiveMatrix, [...point, 1]);
                const adjustedW = Math.max(w, 0.1);
                
                return [
                    (x / adjustedW) + this.canvas.width / 2,
                    (y / adjustedW) + this.canvas.height / 2
                ];
            }
            
            projectAxonometric(point) {
                const scale = 80;
                const angle = Math.PI / 6; // 30 градусов
                
                const axonometricMatrix = [
                    [Math.cos(angle), 0, -Math.sin(angle), 0],
                    [Math.sin(angle)*Math.sin(angle), Math.cos(angle), Math.cos(angle)*Math.sin(angle), 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 1]
                ];
                
                let [x, y, z, w] = TransformationMatrix.multiplyMatrixVector(axonometricMatrix, [...point, 1]);
                
                return [
                    x * scale + this.canvas.width / 2,
                    this.canvas.height / 2 - y * scale
                ];
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                let transformMatrix = TransformationMatrix.getIdentityMatrix();
                
                // Применяем отражение в первую очередь
                const reflectionMatrix = TransformationMatrix.getReflectionMatrix(
                    this.transformParams.reflectXY,
                    this.transformParams.reflectXZ,
                    this.transformParams.reflectYZ
                );
                transformMatrix = TransformationMatrix.multiplyMatrices(transformMatrix, reflectionMatrix);
                
                // Вращение вокруг произвольной прямой
                if (this.transformParams.rotationAngle !== 0) {
                    const rotationMatrix = TransformationMatrix.getRotationAroundLineMatrix(
                        this.transformParams.lineA,
                        this.transformParams.lineB,
                        this.transformParams.rotationAngle
                    );
                    transformMatrix = TransformationMatrix.multiplyMatrices(transformMatrix, rotationMatrix);
                }
                
                // Вращение вокруг прямой через центр, параллельной координатной оси
                if (this.transformParams.parallelRotationAngle !== 0) {
                    const parallelRotationMatrix = TransformationMatrix.getRotationAroundParallelAxisMatrix(
                        this.transformParams.parallelAxis,
                        this.transformParams.parallelRotationAngle,
                        this.transformParams.parallelOffsetY,
                        this.transformParams.parallelOffsetZ,
                        this.currentFigure.center
                    );
                    transformMatrix = TransformationMatrix.multiplyMatrices(transformMatrix, parallelRotationMatrix);
                }
                
                // Масштабирование относительно центра
                const scaleMatrix = TransformationMatrix.getScaleAroundCenterMatrix(
                    this.transformParams.scale,
                    this.currentFigure.center
                );
                transformMatrix = TransformationMatrix.multiplyMatrices(transformMatrix, scaleMatrix);
                
                // Остальные преобразования
                const transformations = [
                    TransformationMatrix.getRotationXMatrix(this.transformParams.rotateX),
                    TransformationMatrix.getRotationYMatrix(this.transformParams.rotateY),
                    TransformationMatrix.getRotationZMatrix(this.transformParams.rotateZ),
                    TransformationMatrix.getTranslationMatrix(
                        this.transformParams.translateX,
                        this.transformParams.translateY,
                        this.transformParams.translateZ
                    )
                ];
                
                transformations.forEach(matrix => {
                    transformMatrix = TransformationMatrix.multiplyMatrices(transformMatrix, matrix);
                });
                
                // Преобразование и отрисовка
                const transformedVertices = this.currentFigure.vertices.map(vertex => {
                    const transformed = TransformationMatrix.multiplyMatrixVector(transformMatrix, vertex.toArray());
                    return this.currentProjection === 'perspective' 
                        ? this.projectPerspective(transformed)
                        : this.projectAxonometric(transformed);
                });
                
                // Отрисовка рёбер
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.currentFigure.faces.forEach(face => {
                    this.ctx.beginPath();
                    face.vertexIndices.forEach((vertexIndex, i) => {
                        const [x, y] = transformedVertices[vertexIndex];
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    });
                    const [firstX, firstY] = transformedVertices[face.vertexIndices[0]];
                    this.ctx.lineTo(firstX, firstY);
                    this.ctx.stroke();
                });
                
                // Отрисовка вершин
                this.ctx.fillStyle = '#e74c3c';
                transformedVertices.forEach(([x, y]) => {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Отрисовка прямой для вращения
                this.drawRotationLine();
            }
            
            drawRotationLine() {
                const project = this.currentProjection === 'perspective' 
                    ? this.projectPerspective.bind(this) 
                    : this.projectAxonometric.bind(this);
                
                const pointA = this.transformParams.lineA.toArray();
                const pointB = this.transformParams.lineB.toArray();
                
                const projectedA = project(pointA);
                const projectedB = project(pointB);
                
                this.ctx.strokeStyle = '#f39c12';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(projectedA[0], projectedA[1]);
                this.ctx.lineTo(projectedB[0], projectedB[1]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Отрисовка точек A и B
                this.ctx.fillStyle = '#f39c12';
                this.ctx.beginPath();
                this.ctx.arc(projectedA[0], projectedA[1], 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(projectedB[0], projectedB[1], 5, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            new PolyhedronViewer();
        });
    </script>
</body>
</html>
